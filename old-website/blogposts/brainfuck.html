<div class="entry" id="04-01-2019">
  <h1>Brainf*ck galore</h1>
  <h2>04-01-2019</h2>
  <i>Mild swearing ahead. That's just the cost of doing business when it comes to Brainfuck.</i>
  <p>Happy new year! Can you believe that the second decade of this millenium is almost over? That's crazy to me. To celebrate the new year I've been doing a lot of Brainfuck-related programming. Not actually <i>in</i> Brainfuck, god forbid, but writing interpreters/compilers for it.</p>
  <p>For those unaware, Brainfuck is an esoteric programming language invented in the 90s by a sadistic psychopath called Urban MÃ¼ller. It exists not really to be programmed in as much as to act as a demonstration of the simplest possible programming language. It's essentially just a turing machine. You have a big strip of memory that your tapehead can move across (the < and > characters), and you can increment or decrement whatever the tapehead points at (+ and -). Looping is accomplished with [ and ], with two simple rules. One: when you reach the [ character, if the tapehead is pointing at a zero, skip to the associated ], otherwise continue as normal. Two: when you reach ] character, jump back to the associated [. That's really about it, except for the . and , characters which handle one byte of output and input respectively.</p>
  <p>My first Brainfuck project is an <a href="https://github.com/pixlark/Brainfuck-compiler">x86_64 Brainfuck compiler</a>. This was written in C (like almost all of my projects) and basically just translates the actions of Brainfuck into assembly code that uses the register r12 to represent the tapehead, and uses any and all available RAM below the stack to represent the "infinite" tape. The project was actually pretty simple, since the only real challenge was dealing with x86_64, which I've never used before. Getting input and output to work was certainly tricky, but apart from that I didn't have too much trouble. Overall, it was a really interesting experience, and makes me excited to work on more serious compilers in the future.</p>
  <p>The other Brainfuck project is an interpreter, but with a twist: <a href="https://github.com/pixlark/haskell-Brainfuck">it's written in Haskell</a>. For those who have never heard of Haskell, it's a purely functional programming language. The design of the language is such that it is literally impossible to have side-effects. All functions are defined purely, like in mathematics. This makes writing an interpreter for something so completely <i>un</i>-functional as Brainfuck an interesting task. But I got it working, and I'm very happy with the result, as it's the first real project I've completed in Haskell.</p>
  <p>There's an interesting theoretical side to the Haskell Brainfuck interpreter in that Brainfuck is, as I said earlier, essentially just a Turing machine. And Haskell is a descendant of something called lambda calculus, which is a form of mathematics invented in the 40s by Alonzo Church. The point of lambda calculus was to reduce mathemtics to it's least complex form. There are no numbers in lambda calculus, no such thing as truthhood or falsehood or operations like addition and subtraction. All you can do is create functions that take parameters and return a value. What are the parameters of those functions, then? Other functions, of course. Church proved that the lambda calculus, for all it's infuriating simplicity, is formally equivalent to the rest of mathematics. Around the same time, Alan Turing proved that his Turing machine was formally equivalent to any more complicated machine---that is, no matter how complicated you make a computer, the Turing machine can do everything that it can (albeit far slower).</p>
  <p>Here's the interesting part: Turing and Church came together at some point and proved that lambda calculus and the Turing machine were <i>also</i> formally equivalent. In a way, that's kind of what this Brainfuck interpreter shows off. Haskell is purely functional and purely a descendant of lambda calculus. Brainfuck is purely imperative and purely a descendant of the Turing machine. And yet, Haskell can model Brainfuck. I just find that so interesting.</p>
</div>
